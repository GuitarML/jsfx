/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
desc:Humonica - Harmoniser/Harmonizer (by Geraint Luff)

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:attack_ms=1<0,100,1>-Attack (ms)
slider2:release_ms=10<1,300,1>-Release (ms)
slider3:window_ms=30<20,150,1>-Window (ms)
slider4:crossover_percent=60<50,90,1>-Crossover (%)
slider5:latency_switch=0<0,1,1{on,off}>-Latency compensation
slider6:stereo_switch=0<0,1,1{2ch,1ch}>-Stereo
slider7:timbre_shift_semitones=0<-12,12,0.1>-Timbre shift (semitones)
slider8:timbre_shift_tracking=0<-1,1,0.01>-Timbre key-tracking (relative to middle C)
slider9:lowpass_freq_khz=8<1,20,0.1>-Lowpass (kHz)
slider10:vibrato_tracking=0<0,1,0.01>-Vibrato tracking
slider11:tonality_limit=0<0,0.5,0.01>-Tonality limit
slider12:volume_norm=0<0,1,0.01>-Volume normalisation
slider13:timbre_enhance=0<0,1,0.01>-Timbre enhance

import ui-lib.jsfx-inc
import synth-framework.jsfx-inc
import filter-utils.jsfx-inc

@init

FFT_MAX_SIZE = 32768;
MAX_WINDOW_MS = 200;
MAX_WINDOW_SAMPLES = srate*MAX_WINDOW_MS*0.001;

freemem = 0;
freemem = (fft_block = freemem) + FFT_MAX_SIZE*2;
kernel_length = MAX_WINDOW_SAMPLES;
freemem = (kernelA0 = freemem) + kernel_length;
freemem = (kernelA1 = freemem) + kernel_length;
freemem = (kernelB0 = freemem) + kernel_length;
freemem = (kernelB1 = freemem) + kernel_length;
input_buffer_length = MAX_WINDOW_SAMPLES;
freemem = (input_buffer0 = freemem) + input_buffer_length;
freemem = (input_buffer1 = freemem) + input_buffer_length;

freemem = ui_setup(freemem);
freemem = synth_setup(freemem, 3/*NOTE: TIMBRE_FACTOR, WAVELENGTH, INDEX*/);

freemem = filter_buffer_init(filter_left = freemem);
freemem = filter_buffer_init(filter_right = freemem);

freemem = filter_buffer_init(freq_factor_filter = freemem);
filter_buffer_highpass(freq_factor_filter, 3, 1.5);

@block

attack_samples = srate*attack_ms*0.001;
release_samples = srate*release_ms*0.001;
window_samples = srate*window_ms*0.001;
interval_samples = window_samples*(1 - crossover_percent/100);
fft_size = pow(2, ceil(log(window_samples*1.5)/log(2)));
abs(timbre_shift_semitones) > 0.1 ? (
	timbre_shift_factor = pow(2, timbre_shift_semitones/12);
) : (
	timbre_shift_factor = 1;
);

input_buffer0[input_index] = spl0;
input_buffer1[input_index] = spl1;

synth_block();

latency_samples = latency_switch ? window_samples*0.5 + interval_samples : 0;

pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = latency_samples;

note = synth_note_first();
while (note > 0) (
	note[0/*NOTE:TIMBRE_FACTOR*/] = pow(2, timbre_shift_tracking*(synth_midinote(note) - 60)/12);
	note = synth_note_next(note);
);

lowpass_freq = lowpass_freq_khz*1000;
filter_buffer_lowpass(filter_left, lowpass_freq, 1.4);
filter_buffer_lowpass(filter_right, lowpass_freq, 1.4);

freq_slew = 1/(interval_samples + 0.03*srate);
!freq_factor ? freq_factor = 1;

tonality_smooth_seconds = 0.05;
tonality_smooth_slew = 1/(tonality_smooth_seconds*srate);

wavelength_average_seconds = 0.3;
wavelength_average_slew = 1/(wavelength_average_seconds*srate);
//wavelength_average = target_wavelength = 0;

@sample

input_buffer0[input_index] = spl0;
input_buffer1[input_index] = spl1;
input_index += 1;
input_index >= input_buffer_length ? (
	input_index = 0;
);

function fill_kernel(kernel, buffer, secondary_buffer) local(peak, norm_factor, sum1, sum2, mag2, max_abs, i, i2, ratio, window_value, index, real, imag, mag) (
	i = 0;
	max_abs = 0;
	// Fill with input
	while (i < window_samples && i < fft_size) (
		ratio = i/window_samples;
		window_value = 0.5 - 0.5*cos(ratio*2*$pi);
		index = input_index - i;
		while (index < 0) (
			index += input_buffer_length;
		);
		fft_block[i*2] = buffer[index]*window_value;
		max_abs = max(max_abs, abs(buffer[index]));
		secondary_buffer >= 0 ? (
			fft_block[i*2 + 1] = secondary_buffer[index]*window_value;
			max_abs = max(max_abs, abs(secondary_buffer[index]));
		) : (
			fft_block[i*2 + 1] = 0;
		);
		i += 1;
	);
	max_abs > 0.00000001 ? (
		while (i < fft_size) (
			fft_block[i*2] = 0;
			fft_block[i*2 + 1] = 0;
			i += 1;
		);

		// Zero-phase
		fft(fft_block, fft_size);
		fft_block[0] = fft_block[1] = 0;
		i = 1;

		sum1 = sum2 = 0;
		debug.realpeak = 0;
		while (i < fft_size) (
			real = fft_block[i*2];
			imag = fft_block[i*2 + 1];
			mag2 = real*real + imag*imag;
			mag = sqrt(mag2);
			sum1 += mag;
			sum2 += mag2;

			fft_block[i*2] = mag/fft_size;
			debug.realpeak = max(debug.realpeak, mag/fft_size);
			fft_block[i*2 + 1] = 0;
			i += 1;
		);
		(volume_norm || timbre_enhance) ? (
			peak = 4*sum2/sum1/fft_size;
			debug.peak = peak;
			debug.window_samples = window_samples;
			debug.fft_size = fft_size;
			norm_factor = min(100, pow(0.1*window_samples/sqrt(sum2), volume_norm));
			debug.norm_factor;
			i = 0;
			timbre_enhance ? (
				while (i < fft_size) (
					fft_block[i*2] = norm_factor*peak*pow(fft_block[i*2]/peak, timbre_enhance + 1);
					i += 1;
				);
			) : (
				while (i < fft_size) (
					fft_block[i*2] *= norm_factor;
					i += 1;
				);
			);
		);
		ifft(fft_block, fft_size);

		// Zero out kernel
		i = 0;
		while (i < kernel_length) (
			kernel[i] = 0;
			i += 1;
		);
		// Place result in kernel
		i = 0;
		window_value = (secondary_buffer >= 0) ? sqrt(0.5) : 1;
		while (i < fft_size*0.5 && i < kernel_length*0.5) (
			i2 = i ? (kernel_length - i) : 0;
			kernel[i] = fft_block[i*2]*window_value;
			kernel[i2] = kernel[i];
			i += 1;
		);
	) : (
		i = 0;
		i < kernel_length ? (
			kernel[i] = 0;
			i += 1;
		);
	);
);

interval_index += 1;
interval_index >= interval_samples ? (
	interval_index = 0;

	// Swap kernels
	tmp = kernelA0;
	kernelA0 = kernelB0;
	kernelB0 = tmp;
	tmp = kernelA1;
	kernelA1 = kernelB1;
	kernelB1 = tmp;

	stereo_switch ? (
		fill_kernel(kernelB0, input_buffer0, -1);
		fill_kernel(kernelB1, input_buffer1, -1);
	) : (
		fill_kernel(kernelB0, input_buffer0, input_buffer1);
		i = 0;
		while (i < kernel_length) (
			kernelB1[i] = kernelB0[i];
			i += 1;
		);
	);

	vibrato_tracking || tonality_limit ? (
		lowest_value = 0;
		highest_value = 0;
		highest_index = 0;
		i = 0;
		while (i < kernel_length/2) (
			value = (kernelB0[i] + kernelB1[i]);
			value < lowest_value ? (
				highest_value = highest_index = 0;
				lowest_value = value;
			) : value > highest_value ? (
				highest_value = value;
				highest_index = i;
			);
			i += 1;
		);
		highest_index ? (
			target_wavelength = highest_index;
		);

		tonality_limit ? (
			first_value = (kernelB0[0] + kernelB1[0]);
			tonality = first_value ? highest_value/first_value : 0;
			factor = max(0, min(1, (tonality - tonality_limit)/tonality_limit));
			tonality_factor += (factor - tonality_factor)*tonality_smooth_slew*interval_samples;

			i = 0;
			while (i < kernel_length) (
				kernelB0[i] *= tonality_factor;
				kernelB1[i] *= tonality_factor;
				i += 1;
			);
		);
	);
);
kernel_crossfade = interval_index/interval_samples;

vibrato_tracking ? (
	low_factor = 0.98;
	high_factor = 1/low_factor;
	wavelength_average += (target_wavelength - wavelength_average)*wavelength_average_slew;
	wavelength_average = max(target_wavelength*low_factor, min(target_wavelength*high_factor, wavelength_average));
	target_ratio = target_wavelength/wavelength_average;
	//target_ratio = max(low_factor, min(high_factor, target_ratio));
	target_ratio = 1 + filter_buffer_sample(freq_factor_filter, target_ratio - 1);
	target_ratio = max(low_factor, min(high_factor, target_ratio));

	freq_factor += (target_ratio - freq_factor)*freq_slew;
) : (
	freq_factor = 1;
);

spl0 = spl1 = 0;

synth_sample();

note = synth_note_first();
while (note > 0) (
	synth_needs_init(note) ? (
		note[1/*NOTE:WAVELENGTH*/] = srate/synth_freq(note);
		note[2/*NOTE:INDEX*/] = floor(rand()*note[1/*NOTE:WAVELENGTH*/]);
		note[0/*NOTE:TIMBRE_FACTOR*/] = pow(2, timbre_shift_tracking*(synth_midinote(note) - 60)/12);
	);

	amp = synth_velocity(note)/127;
	attack = synth_attack(note) - latency_samples;
	attack >= 0 ? (
		attack < attack_samples ? (
			amp *= attack/attack_samples;
		);
		release = synth_sustain_release(note) - latency_samples;
		release > 0 ? (
			release >= release_samples ? (
				synth_stop(note);
				amp = 0;
			) : (
				amp *= (1 - release/release_samples);
			);
		);

		index = (note[2/*NOTE:INDEX*/] += 1);
		wavelength = note[1/*NOTE:WAVELENGTH*/];
		index >= wavelength ? (
			while (index >= wavelength) (
				index -= wavelength;
			);
			vibrato_factor = vibrato_tracking ? pow(freq_factor, min(1, attack/(0.3*srate))*vibrato_tracking) : 1;
			wavelength = note[1/*NOTE:WAVELENGTH*/] = srate/synth_freq(note)*vibrato_factor;
			while (index >= wavelength) (
				index -= wavelength;
			);
			note[2/*NOTE:INDEX*/] = index;
		);

		timbre_factor = timbre_shift_factor*note[0/*NOTE:TIMBRE_FACTOR*/];
		phase = index/wavelength;
		indexA = min(index*timbre_factor, kernel_length*0.5 - 1);
		indexB = max(kernel_length*0.5, kernel_length - wavelength*timbre_factor + indexA);
		floor_indexA = floor(indexA);
		floor_indexB = floor(indexB);
		floor_indexA2 = floor_indexA + 1;
		floor_indexA2 >= kernel_length ? floor_indexA2 -= kernel_length;
		floor_indexB2 = floor_indexB + 1;
		floor_indexB2 >= kernel_length ? floor_indexB2 -= kernel_length;
		ratioA = indexA - floor_indexA;
		ratioB = indexB - floor_indexB;

		valueA = kernelA0[floor_indexA];
		valueA += (kernelA0[floor_indexA2] - valueA)*ratioA;
		valueB = kernelA0[floor_indexB];
		valueB += (kernelA0[floor_indexB2] - valueB)*ratioB;
		value = valueA + (valueB - valueA)*phase;
		left = value;

		valueA = kernelA1[floor_indexA];
		valueA += (kernelA1[floor_indexA2] - valueA)*ratioA;
		valueB = kernelA1[floor_indexB];
		valueB += (kernelA1[floor_indexB2] - valueB)*ratioB;
		value = valueA + (valueB - valueA)*phase;
		right = value;

		// Crossfade
		valueA = kernelB0[floor_indexA];
		valueA += (kernelB0[floor_indexA2] - valueA)*ratioA;
		valueB = kernelB0[floor_indexB];
		valueB += (kernelB0[floor_indexB2] - valueB)*ratioB;
		value = valueA + (valueB - valueA)*phase;
		left += (value - left)*kernel_crossfade;

		valueA = kernelB1[floor_indexA];
		valueA += (kernelB1[floor_indexA2] - valueA)*ratioA;
		valueB = kernelB1[floor_indexB];
		valueB += (kernelB1[floor_indexB2] - valueB)*ratioB;
		value = valueA + (valueB - valueA)*phase;
		right += (value - right)*kernel_crossfade;

		spl0 += left*amp;
		spl1 += right*amp;
	);

	note = synth_note_next(note);
);

spl0 = filter_buffer_sample(filter_left, spl0);
spl1 = filter_buffer_sample(filter_right, spl1);

@gfx 650 350

function labelled_dial(value, low, high, bias, label, number_format) (
	ui_push_height(50);
		value = control_dial(value, low, high, bias);
	ui_pop();
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		number_format >= 0 ? (
			ui_textnumber(value, number_format);
		);
	ui_pop();
	value;
);

function labelled_switch(value, label, text) (
	ui_push_height(30);
		ui_push_width(60);
			value = control_switch(value);
		ui_pop();
	ui_pop();
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		ui_text(text);
	ui_pop();
	value;
);
control_start("main", "default");

ui_screen() == "main" ? (
	control_navbar("Humonica", "help", "help");

	ui_split_top(150);
		ui_split_leftratio(4/7);
			control_group("Analysis");
			ui_split_leftratio(1/4);
				window_ms = labelled_dial(window_ms, 5, 150, 1.5, "Window", "%ims");
			ui_split_next();
				crossover_percent = labelled_dial(crossover_percent, 50, 90, 0, "Crossover", "%i%%");
			ui_split_next();
				latency_switch = labelled_switch(latency_switch, "Latency", latency_switch ? "compensated" : "zero");
			ui_split_next();
				stereo_switch = labelled_switch(stereo_switch, "Stereo", stereo_switch ? "separate" : "joined");
			ui_pop();
		ui_pop();

		control_group("Timbre");
		ui_split_leftratio(1/3);
			timbre_shift_semitones = labelled_dial(timbre_shift_semitones, -12, 12, 0, "Shift", "%.1f st");
			ui_click() && ui_clickcount() == 2 ? timbre_shift_semitones = 0;
		ui_split_next();
			timbre_shift_tracking = labelled_dial(timbre_shift_tracking, -0.5, 0.5, 0, "Tracking", "(relative to\nmiddle C)");
			ui_click() && ui_clickcount() == 2 ? timbre_shift_tracking = 0;
		ui_split_next();
			lowpass_freq_khz = labelled_dial(lowpass_freq_khz, 1, 20, 2, "Filter", "%.f kHz");
			ui_click() && ui_clickcount() == 2 ? lowpass_freq_khz = 8;
		ui_pop();
	ui_pop();

	ui_split_leftratio(4/7);
		ui_split_leftratio(2/4);
			control_group("Envelope");
			ui_split_leftratio(1/2);
				attack_ms = labelled_dial(attack_ms, 0, 100, 3, "Attack", "%ims");
			ui_split_next();
				release_ms = labelled_dial(release_ms, 0, 300, 3, "Release", "%ims");
			ui_pop();
		ui_pop();

		control_group("Pitch & Tonality");
		ui_split_leftratio(1/2);
			vibrato_tracking = max(0, labelled_dial(vibrato_tracking, -0.001, 1, 0, "Vib", "tracking"));
		ui_split_next();
			tonality_limit = labelled_dial(tonality_limit, 0, 0.5, 0, "Tonality", "limit");
		ui_pop();
	ui_pop();

	ui_pad();
	control_background_technical();
	ui_graph_step(kernelA0[0] ? kernelA0 : kernelA1, window_samples/2, 1, 0.00000001, 0.00000001);
	control_finish_technical();
) : ui_screen() == "help" ? (
	control_navbar("Humonica - Help", -1, -1);

	ui_align(0, 0);
	ui_wraptext("Window: controls how much input audio is used to calculate the impulse for resynthesis.  Lower values give a faster-changing sound (better time-resolution), but reduced frequency resolution.\n\nOverlap: controls how often the impulse is recalculated, as a function of the window length.  Higher values mean recalculating more often, which gives a smoother result, at the expense of more calculation.\n\nLatency: the impulse is calculated using input audio. This switch chooses between zero-latency (\"live\") mode, where the analysis will always be slightly behind the input audio (depending on window length and overlap amount) or whether some extra latency is added to compensate.\n\nStereo: the left and right inputs can either be combined (their energy is added together) or calculated separately. 1-channel mode is slightly more efficient, so should be used unless you particularly need separate stereo channels.");
) : ui_system();
