desc:MIDI Harmony (by Geraint Luff)

in_pin:none
out_pin:none

slider1:input_source=0<0,1,1{fixed,MIDI}>-Target
slider2:shift_up_only=0<0,1,1{up and down,up only}>-Shift mode
slider3:fixed_note_mode=0<0,1,1{chord,note}>-Note
slider4:fixed_centre=60<0,127,1>-Centre (MIDI note)
slider5:fixed_range=12<1,36,1>-Range (MIDI note)
slider6:sequence_length=8<2,32,1>-Sequence length
slider7:repeat_interval=0<0,1,0.25>-Interval (1/4)
slider8:free_mode=1<0,1,1{beats,note-on}>-Sequence Sync

import ui-lib.jsfx-inc

@init

output_channel = 0;

freemem = 0;
freemem = ui_setup(freemem);

// Set up sequence
freemem = (sequence_pitch = freemem) + 1000;
freemem = (sequence_velocity = freemem) + 1000;
max_vel = 0;
i = 0;
while (i < 100) (
	max_vel = max(max_vel, sequence_velocity[i]);
	i += 1;
);
!max_vel ? (
	i = 0;
	while (i < 100) (
		v = sqrt(3)*(sqrt(i%16) + 1);
		v = v - floor(v);
		sequence_velocity[i] = 0.2 + 0.8*v;
		v = sqrt(2)*(i + 1);
		v = v - floor(v);
		sequence_pitch[i] = v*2 - 1;
		i += 1;
	);
);

// Set up note filtering
freemem = (input_notes = freemem) + 128;
freemem = (allowed_notes = freemem) + 128;
freemem = (prev_output_notes = freemem) + 128;
freemem = (output_notes = freemem) + 128;

@block

!free_mode && play_state > 0 && play_state != 6 ? (
	beats = beat_position;
);
beats_per_sample = tempo/60/srate;

function recalculate(offset) local(i, note, note_start, note_end, tmp) (
	i = 0;
	while (i < 12) (
		allowed_notes[i] = input_notes[i];
		i += 1;
	);
	shift_up_only ? (
		while (i < 128) (
			allowed_notes[i] = max(input_notes[i], allowed_notes[i - 12]);
			i += 1;
		);
	) : (
		while (i < 128) (
			note = i%12;
			allowed_notes[note] = max(allowed_notes[note], input_notes[i]);
			i += 1;
		);
		i = 0;
		while (i < 12) (
			note = i + 12;
			while (note < 128) (
				allowed_notes[note] = allowed_notes[i];
				note += 12;
			);
			i += 1;
		);
	);

	tmp = output_notes;
	output_notes = prev_output_notes;
	prev_output_notes = tmp;

	i = 0;
	while (i < 128) (
		output_notes[i] = 0;
		i += 1;
	);

	input_source ? (
		ui_error("MIDI input not supported");
	) : (
		note_start = max(0, floor(fixed_centre - fixed_range));
		note_end = min(127, ceil(fixed_centre + fixed_range));

		i = note_start + 1;
		while (i < note_end) (
			allowed_notes[i] ? (
				dist = (i - fixed_centre)/fixed_range;
				output_notes[i] = allowed_notes[i]*(0.5 + 0.5*cos(dist*$pi));
			);
			i += 1;
		);
	);

	i = 0;
	while (i < 128) (
		output_notes[i] > prev_output_notes[i] ? (
			prev_output_notes[i] ? (
				midisend(offset, $x80|output_channel, i, 0);
			);
			midisend(offset, $x90|output_channel, i, ceil(output_notes[i]));
		) : output_notes[i] < prev_output_notes[i] ? (
			!output_notes[i] ? (
				midisend(offset, $x80|output_channel, i, 0);
			); // TODO: optionally re-send with lower velocity?
		);
		i += 1;
	);
);

function set_sustain(value) (
	value >= 64 ? (
		0;
	) : (
		0;
	);
);

current_offset = 0;
needs_recalculate = 0;
while (midirecv(offset, msg1, note, vel)) (
	offset != current_offset ? (
		needs_recalculate ? recalculate(current_offset);
		needs_recalculate = 0;
		current_offset = offset;
	);

	type = (msg1&240);
	channel = (msg1&15);
	note_modulo = note%12;
	type == $x90 && vel != 0 ? (
		needs_recalculate = 1;
		input_notes[note] = vel;
	) : type == $x80 || (type == $x90 && vel == 0) ? (
		needs_recalculate = 1;
		input_notes[note] = 0;
	) : (
		type == $xB0 ? ( // Controller
			note == 64 ? (
				set_sustain(vel);
			) : note == 121 ? (
				set_sustain(0);
			) : note == 123 || note == 120 ? (
				note = 0;
				while (note < 128) (
					input_notes[note] = 0;
				);
			);
		);
		midisend(type|output_channel, msg1, note, vel);
	);
);
needs_recalculate ? recalculate(current_offset);

@sample

beats += beats_per_sample;

@gfx 640 360

function edit_sequence(seq, low, high, is_vel) local(extra, i, y, x1, x2) (
	extra = (high - low)*0.05;
	low -= extra;
	high += extra;
	control_background_technical();
	is_vel ? (
		ui_color(128, 192, 256);
	);
	i = 0;
	while (i < sequence_length) (
		x1 = floor(ui_left() + i/sequence_length*ui_width());
		x2 = floor(ui_left() + (i + 1)/sequence_length*ui_width());
		repeat_interval && i == beat_interval ? (
			ui_push();
				gfx_a = 0.2;
				gfx_rect(x1, ui_top(), x2 - x1, ui_height());
			ui_pop();
		);
		y = ui_top() + (seq[i] - high)/(low - high)*ui_height();
		is_vel ? (
			ui_push();
				gfx_a = 0.2;
				gfx_rect(x1, y, x2 - x1, ui_bottom() - y);
			ui_pop();
			gfx_line(x1, y, x2, y);
		) : (
			gfx_rect(x1, y - 1, x2 - x1, 3);
		);

		(ui_drag() || ui_mouse_down()) && (ui_mouse_x() + ui_left() > x1 && ui_mouse_x() + ui_left() < x2) ? (
			seq[i] = high + min(1, max(0, ui_mouse_yratio()))*(low - high);
		);

		i += 1;
	);
	control_finish_technical();
);

function labelled_dial(value, low, high, bias, label, number_format) (
	ui_push_height(50);
		value = control_dial(value, low, high, bias);
	ui_pop();
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		number_format >= 0 ? (
			ui_textnumber(value, number_format);
		);
	ui_pop();
	value;
);

function push_labelled(label, number, number_format) (
	ui_push_above(50);
		ui_align(0.5, 0.85);
		ui_text(label);
	ui_pop();
	ui_push_below(50);
		ui_align(0.5, 0.15);
		number_format >= 0 ? (
			ui_textnumber(value, number_format);
		);
	ui_pop();
	ui_push_height(50);
);

ui_start("main");

ui_screen() == "main" ? (
	ui_split_top(100);
		control_background_technical();
		ui_graph_step(output_notes, 128, 1, -127, 127);
		control_finish_technical();
	ui_pop();

	ui_split_top(140);
		ui_split_leftratio(4/7);
			control_group("Range");
			ui_split_leftratio(1/4);
				fixed_centre = labelled_dial(fixed_centre, 0, 127, 0, "Centre", "");
			ui_split_next();
				fixed_range = labelled_dial(fixed_range, 1, 36, 2, "Span", "");
			ui_split_next();
				push_labelled("Shift", 0, shift_up_only ? "up only" : "up/down");
					ui_push_heighttext(-1);
						ui_pad2(-1, 0);
						shift_up_only = control_switch(shift_up_only);
					ui_pop();
				ui_pop();
			ui_split_next();
				push_labelled("Mode", 0, fixed_note_mode ? "note" : "chord");
					ui_push_heighttext(-1);
						ui_pad2(-1, 0);
						fixed_note_mode = control_switch(fixed_note_mode);
					ui_pop();
				ui_pop();
			ui_pop();
		ui_pop();

		ui_split_leftratio(3/3);
			control_group("Sequence");
			ui_split_leftratio(1/3);
				push_labelled("Interval", 0, "");
					ui_push_heighttext(-1);
						ui_pad2(-1, 0);
						sprintf(#repeat_interval, repeat_interval ? "%i/16" : "off", repeat_interval*4);
						repeat_interval = control_selector(repeat_interval, #repeat_interval, min(1, repeat_interval + 0.25), max(0, repeat_interval - 0.25));
					ui_pop();
				ui_pop();
			ui_split_next();
				push_labelled("Length", 0, "");
					ui_push_heighttext(-1);
						ui_pad2(-1, 0);
						sprintf(#sequence_length, "%i", sequence_length);
						sequence_length = control_selector(sequence_length, #sequence_length, min(32, sequence_length*2), max(2, sequence_length/2));
					ui_pop();
				ui_pop();
			ui_split_next();
				push_labelled("Sync", 0, free_mode ? "note-on" : "beats");
					ui_push_heighttext(-1);
						ui_pad2(-1, 0);
						free_mode = control_switch(free_mode);
					ui_pop();
				ui_pop();
			ui_pop();
		ui_pop();
	ui_pop();

	ui_split_topratio(0.5);
		ui_split_lefttext("pitch");
			ui_text("pitch");
		ui_pop();
		edit_sequence(sequence_pitch, -1, 1, 0);
	ui_split_next();
		ui_split_lefttext("pitch");
			ui_text("vel");
		ui_pop();
		edit_sequence(sequence_velocity, 0, 1, 1);
	ui_pop();
) : control_system();

@serialize

si = 0;
sN = 100;
file_var(0, sN);
while (si < sN) (
	file_var(0, sequence_pitch[si]);
	file_var(0, sequence_velocity[si]);
	si += 1;
);
