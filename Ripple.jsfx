/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
desc:Ripple Phaser (by Geraint Luff)

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:band_count=6<1,20,1>Number of bands
slider2:low_freq=200<30,2000>Low freq
slider3:high_freq=6000<1000,18000>High freq
slider4:cycle_phase_offset=0.5<0,1>Phase Offset
slider5:cycle_phase_lfo_hz=0<-10,10>Phase LFO (hz)
slider6:cycle_phase_invbeat=0.5<-4,4,0.5>Phase LFO (/beat)
slider7:filter_mode=0<0,1,1{cut, boost}>-Filter type
slider8:filter_db=12<0,60,0.1>Filter strength (dB)
slider9:filter_width_factor=0.3<0.01,0.7>Filter width
slider10:filter_restoration=1<0,2>Filter compensation

import ui-lib.jsfx-inc
import filter-utils.jsfx-inc

@init

MAX_BAND_COUNT = 20 + 5;

freemem = ui_setup(0);
freemem = (filter_mem = freemem) + 18*MAX_BAND_COUNT;

phase_logger_length = ceil(srate*1/(samplesblock ? samplesblock : 256));
freemem = (phase_logger_buffer = freemem) + phase_logger_length;

g_buffer_length = 1024;
freemem = (g_buffer = freemem) + g_buffer_length;

function filters_to_mem() (
	0;
);

function filters_from_mem() (
	actual_band_count = band_count + 2;
);

function gain_window(x) (
	0.5 - 0.5*cos(x*2*$pi);
);

function calculate_filters() local(i, freq, gain, band_gain, bw, future_samples, future_factor, future_phase, filter_mem_i) (
	filters_to_mem();

	// Calculate filter targets
	// Future time is min(samples_to_next_block, [when the next filter will pop off an edge])
	// Predict that far in future, divide by distance
	future_samples = samples_to_next_block;
	cycle_phase_step > 0 ? (
		future_samples = min(future_samples, ceil((1 - cycle_phase)/cycle_phase_step));
	) : cycle_phase_step < 0 ? (
		future_samples = min(future_samples, ceil(cycle_phase/-cycle_phase_step));
	);
	future_factor = future_samples ? 1/future_samples : 0;

	future_phase = cycle_phase + cycle_phase_step*future_samples;

	bw = filter_width_factor*(log(high_freq/low_freq)/log(2)/band_count);

	i = 0;
	loop(band_count + 2,
		filter_mem_i = filter_mem + 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/*i;
		i >= band_count ? (
			// Magic equations found through trial and error!
			band_width = filter_width_factor*log(high_freq/low_freq)/log(2)/band_count;
			filter_mode == 0 ? (
				band_gain = pow(10, -filter_db/20);
				gain = 1 + (1 - band_gain)*1.2*filter_width_factor*filter_width_factor;
				i == band_count ? (
					freq = 1/(1.18 + band_gain)*low_freq*exp(log(high_freq/low_freq)*(band_count - 0.4)/band_count);
					target_filter.filter_highshelf_gainslope(freq/srate, 1/gain, 1.8 - band_gain);
				) : (
					freq = (1.18 + band_gain)*low_freq*exp(log(high_freq/low_freq)*(0.4)/band_count);
					debug.freq = freq/296.0647;
					target_filter.filter_highshelf_gainslope(freq/srate, gain, 1.8 - band_gain);
				);
			) : (
				band_gain = pow(10, -filter_db/20);
				gain = pow(10, -filter_db*filter_width_factor*1.5/20);
				i == band_count ? (
					freq = 1/(1.18 + 0*band_gain)*low_freq*exp(log(high_freq/low_freq)*(band_count - 1)*1/band_count);
					target_filter.filter_highshelf_gainslope(freq/srate, 1/gain, 1);
				) : (
					freq = (1.18 + 0*band_gain)*low_freq*exp(log(high_freq/low_freq)*(1)/band_count);
					debug.freq = freq/296.0647;
					target_filter.filter_highshelf_gainslope(freq/srate, gain, 1);
				);
			);
		) : (
			freq = low_freq*exp(log(high_freq/low_freq)*(i + future_phase)/band_count);
			filter_mode == 1 ? (
				gain = pow(10, filter_db*gain_window((i + future_phase)/band_count)/20);
				target_filter.filter_band(freq, gain, bw);
			) : (
				gain = pow(10, -filter_db*gain_window((i + future_phase)/band_count)/20);
				target_filter.filter_notch(freq, bw, gain);
			);
		);

		!future_samples ? (
			filter_mem_i[0/*FILTER:A1*/] = target_filter.a1;
			filter_mem_i[1/*FILTER:A2*/] = target_filter.a2;
			filter_mem_i[2/*FILTER:B0*/] = target_filter.b0;
			filter_mem_i[3/*FILTER:B1*/] = target_filter.b1;
			filter_mem_i[4/*FILTER:B2*/] = target_filter.b2;
		);
		filter_mem_i[5/*FILTER:A1_STEP*/] = (target_filter.a1 - filter_mem_i[0/*FILTER:A1*/])*future_factor;
		filter_mem_i[6/*FILTER:A2_STEP*/] = (target_filter.a2 - filter_mem_i[1/*FILTER:A2*/])*future_factor;
		filter_mem_i[7/*FILTER:B0_STEP*/] = (target_filter.b0 - filter_mem_i[2/*FILTER:B0*/])*future_factor;
		filter_mem_i[8/*FILTER:B1_STEP*/] = (target_filter.b1 - filter_mem_i[3/*FILTER:B1*/])*future_factor;
		filter_mem_i[9/*FILTER:B2_STEP*/] = (target_filter.b2 - filter_mem_i[4/*FILTER:B2*/])*future_factor;

		i += 1;
	);

	filters_from_mem();
);

function step_filters() local(i, filter_mem_i) (
	i = 0;
	loop(actual_band_count,
		filter_mem_i = filter_mem + 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/*i;
		filter_mem_i[0/*FILTER:A1*/] += filter_mem_i[5/*FILTER:A1_STEP*/];
		filter_mem_i[1/*FILTER:A2*/] += filter_mem_i[6/*FILTER:A2_STEP*/];
		filter_mem_i[2/*FILTER:B0*/] += filter_mem_i[7/*FILTER:B0_STEP*/];
		filter_mem_i[3/*FILTER:B1*/] += filter_mem_i[8/*FILTER:B1_STEP*/];
		filter_mem_i[4/*FILTER:B2*/] += filter_mem_i[9/*FILTER:B2_STEP*/];
		i += 1;
	);
);

function shift_filters_down() local(i, filter_mem_i) (
	cycle_phase -= 1;

	// Shunt all filters down
	i = band_count*18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/ - 1;
	while (i >= 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/) (
		filter_mem[i] = filter_mem[i - 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/];
		i -= 1;
	);

	// New filter coeffs: 0-gain at low_freq
	bw = filter_width_factor*(log(high_freq/low_freq)/log(2)/band_count);
	target_filter.filter_band(low_freq, 1, bw);
	shift_down_new_filter.filter_band(low_freq, 1, bw);
	// Copy coefficients
	filter_mem_i = filter_mem;
	filter_mem_i[0/*FILTER:A1*/] = target_filter.a1;
	filter_mem_i[1/*FILTER:A2*/] = target_filter.a2;
	filter_mem_i[2/*FILTER:B0*/] = target_filter.b0;
	filter_mem_i[3/*FILTER:B1*/] = target_filter.b1;
	filter_mem_i[4/*FILTER:B2*/] = target_filter.b2;

	// Rewrite output - zero gain, so should be same as input
	filter_mem_i[10/*FILTER:Y1_L*/] = filter_mem_i[11/*FILTER:X1_L*/];
	filter_mem_i[12/*FILTER:Y2_L*/] = filter_mem_i[13/*FILTER:X2_L*/];
	filter_mem_i[14/*FILTER:Y1_R*/] = filter_mem_i[15/*FILTER:X1_R*/];
	filter_mem_i[16/*FILTER:Y2_R*/] = filter_mem_i[17/*FILTER:X2_R*/];

	// Now calculate_filters will do the correct thing
	calculate_filters();
);

function shift_filters_up() local(i, bw, filter_mem_i) (
	cycle_phase += 1;

	// Shunt all filters up
	i = 0;
	while (i < (band_count - 1)*18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/) (
		filter_mem[i] = filter_mem[i + 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/];
		i += 1;
	);

	// New filter coeffs: 0-gain at high_freq
	bw = filter_width_factor*(log(high_freq/low_freq)/log(2)/band_count);
	target_filter.filter_band(high_freq, 1, bw);
	shift_up_new_filter.filter_band(high_freq, 1, bw);
	// Copy coefficients
	filter_mem_i = filter_mem + (band_count - 1)*18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/;
	filter_mem_i[0/*FILTER:A1*/] = target_filter.a1;
	filter_mem_i[1/*FILTER:A2*/] = target_filter.a2;
	filter_mem_i[2/*FILTER:B0*/] = target_filter.b0;
	filter_mem_i[3/*FILTER:B1*/] = target_filter.b1;
	filter_mem_i[4/*FILTER:B2*/] = target_filter.b2;

	// Rewrite output - zero gain, so should be same as input
	filter_mem_i[10/*FILTER:Y1_L*/] = filter_mem_i[11/*FILTER:X1_L*/];
	filter_mem_i[12/*FILTER:Y2_L*/] = filter_mem_i[13/*FILTER:X2_L*/];
	filter_mem_i[14/*FILTER:Y1_R*/] = filter_mem_i[15/*FILTER:X1_R*/];
	filter_mem_i[16/*FILTER:Y2_R*/] = filter_mem_i[17/*FILTER:X2_R*/];

	// Now calculate_filters will do the correct thing
	calculate_filters();
);

function correction_amp(freq) local(wi, wr, hi, hr, pr, pi, pm2, zr, zi, tr, ti, i, filter_mem_i) (
	hr = 1;
	hi = 0;
	wr = cos(2*$pi*freq/srate);
	wi = sin(2*$pi*freq/srate);
	w2r = cos(4*$pi*freq/srate);
	w2i = sin(4*$pi*freq/srate);

	i = 0;
	while (i < actual_band_count) (
		filter_mem_i = filter_mem + 18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/*i;
		// Numerator (B)
		zr = filter_mem_i[2/*FILTER:B0*/] + filter_mem_i[3/*FILTER:B1*/]*wr + filter_mem_i[4/*FILTER:B2*/]*w2r;
		zi = filter_mem_i[3/*FILTER:B1*/]*wi + filter_mem_i[4/*FILTER:B2*/]*w2i;
		// Denominator (B)
		pr = 1 + filter_mem_i[0/*FILTER:A1*/]*wr + filter_mem_i[1/*FILTER:A2*/]*w2r;
		pi = filter_mem_i[0/*FILTER:A1*/]*wi + filter_mem_i[1/*FILTER:A2*/]*w2i;
		pm2 = pr*pr + pi*pi;

		// Multiply by numerator
		tr = hr;
		ti = hi;
		hr = tr*zr - ti*zi;
		hi = tr*zi + ti*zr;

		// Divide by denominator
		tr = hr;
		ti = hi;
		hr = tr*pr + ti*pi;
		hi = ti*pr - tr*pi;
		hr /= pm2;
		hi /= pm2;
		i += 1;
	);
	sqrt(hr*hr + hi*hi);
);

/*
function correction_phase(freq) local(wi, wr, hi, hr, pr, pi, pm2, zr, zi, tr, ti, i) (
	hr = 1;
	hi = 0;
	wr = cos(2*$pi*freq/srate);
	wi = sin(2*$pi*freq/srate);
	w2r = cos(4*$pi*freq/srate);
	w2i = sin(4*$pi*freq/srate);

	i = 0;
	while (i < correction_N) (
		zr = correction_b0[i] + correction_b1[i]*wr + correction_b2[i]*w2r;
		zi = correction_b1[i]*wi + correction_b2[i]*w2i;
		pr = 1 + correction_a1[i]*wr + correction_a2[i]*w2r;
		pi = correction_a1[i]*wi + correction_a2[i]*w2i;
		pm2 = pr*pr + pi*pi;

		tr = hr;
		ti = hi;
		hr = tr*zr - ti*zi;
		hi = tr*zi + ti*zr;

		tr = hr;
		ti = hi;
		hr = tr*pr + ti*pi;
		hi = ti*pr - tr*pi;
		hr /= pm2;
		hi /= pm2;
		i += 1;
	);
	atan2(hi, hr);
);
*/

cycle_phase = play_position*cycle_phase_lfo_hz + beat_position*cycle_phase_invbeat + cycle_phase_offset;
cycle_phase -= floor(cycle_phase);
cycle_phase_offset_prev = cycle_phase_offset;

samples_to_next_block = 1000;
calculate_filters();

@block

secondsblock = samplesblock/srate;

beat_blockdelta = secondsblock*tempo/60;
cycle_phase_blockdelta = beat_blockdelta*cycle_phase_invbeat + secondsblock*cycle_phase_lfo_hz;

// If we're playing

play_state > 0 && play_state != 6 ? (
	cycle_phase_lfo_hz ? (
		// Difference between expectation and actual beat-based phase + offset
		cycle_phase_adjustment = (beat_position - beat_position_next_block)*cycle_phase_invbeat
			+ cycle_phase_offset - cycle_phase_offset_prev;
	) : (
		// No LFO - lock exactly to beat + offset
		cycle_phase_adjustment = beat_position*cycle_phase_invbeat + cycle_phase_offset - cycle_phase;
	);
) : (
	cycle_phase_invbeat || cycle_phase_lfo_hz ? (
		// We're freewheeling anyway, just track offset changes
		cycle_phase_adjustment = cycle_phase_offset - cycle_phase_offset_prev;
	) : (
		// Everything's set to zero - it's just following the offset
		cycle_phase_adjustment = cycle_phase_offset - cycle_phase;
	);
);

cycle_phase_adjustment -= floor(cycle_phase_adjustment + 0.5);
// Make up for the difference during this block
cycle_phase_blockdelta += cycle_phase_adjustment;

samples_to_next_block = samplesblock;
cycle_phase_step = cycle_phase_blockdelta/samplesblock;

// Get ready for the next block
beat_position_next_block = beat_position + beat_blockdelta;
cycle_phase_offset_prev = cycle_phase_offset;

calculate_filters();

phase_logger_buffer[phase_logger_index] = cycle_phase;
phase_logger_index += 1;
phase_logger_index >= phase_logger_length ? (
	phase_logger_index = 0;
);

@sample

x0_l = spl0;
x0_r = spl1;

i = 0;
loop(actual_band_count,
	filter_mem_i = filter_mem + i*18/*FILTER: A1, A2, B0, B1, B2, A1_STEP, A2_STEP, B0_STEP, B1_STEP, B2_STEP, Y1_L, X1_L, Y2_L, X2_L, Y1_R, X1_R, Y2_R, X2_R*/;

	y0_l = x0_l*filter_mem_i[2/*FILTER:B0*/]
		+ filter_mem_i[11/*FILTER:X1_L*/]*filter_mem_i[3/*FILTER:B1*/]
		+ filter_mem_i[13/*FILTER:X2_L*/]*filter_mem_i[4/*FILTER:B2*/]
		- filter_mem_i[10/*FILTER:Y1_L*/]*filter_mem_i[0/*FILTER:A1*/]
		- filter_mem_i[12/*FILTER:Y2_L*/]*filter_mem_i[1/*FILTER:A2*/];
	filter_mem_i[13/*FILTER:X2_L*/] = filter_mem_i[11/*FILTER:X1_L*/];
	filter_mem_i[11/*FILTER:X1_L*/] = x0_l;
	filter_mem_i[12/*FILTER:Y2_L*/] = filter_mem_i[10/*FILTER:Y1_L*/];
	filter_mem_i[10/*FILTER:Y1_L*/] = y0_l;
	x0_l = y0_l;

	y0_r = x0_r*filter_mem_i[2/*FILTER:B0*/]
		+ filter_mem_i[15/*FILTER:X1_R*/]*filter_mem_i[3/*FILTER:B1*/]
		+ filter_mem_i[17/*FILTER:X2_R*/]*filter_mem_i[4/*FILTER:B2*/]
		- filter_mem_i[14/*FILTER:Y1_R*/]*filter_mem_i[0/*FILTER:A1*/]
		- filter_mem_i[16/*FILTER:Y2_R*/]*filter_mem_i[1/*FILTER:A2*/];
	filter_mem_i[17/*FILTER:X2_R*/] = filter_mem_i[15/*FILTER:X1_R*/];
	filter_mem_i[15/*FILTER:X1_R*/] = x0_r;
	filter_mem_i[16/*FILTER:Y2_R*/] = filter_mem_i[14/*FILTER:Y1_R*/];
	filter_mem_i[14/*FILTER:Y1_R*/] = y0_r;
	x0_r = y0_r;

	i += 1;
);

spl0 = x0_l;
spl1 = x0_r;

step_filters();

cycle_phase += cycle_phase_step;
while (cycle_phase >= 1) (
	shift_filters_down();
);
while (cycle_phase < 0) (
	shift_filters_up();
);

samples_to_next_block -= 1;

@gfx 510 660

control_start("main", "tron");

ui_screen() == "main" ? (
	ui_split_bottom(200);
		ui_split_topratio(0.5);
			ui_split_rightratio(3/6);
				control_group("filters");
			ui_pop();
		ui_split_next();
			ui_split_rightratio(3/6);
				control_group("bands");
				ui_split_leftratio(1/3);
					sprintf(#band_count, "%i", band_count);
					band_count = control_selector(band_count, #band_count, min(MAX_BAND_COUNT, band_count + 1), max(1, band_count - 1));
				ui_split_next();
				ui_split_next();
				ui_pop();
			ui_pop();

			control_group("LFO");
			ui_split_leftratio(1/3);
			ui_split_next();
			ui_split_next();
				control_background_technical();
				ui_graph(phase_logger_buffer, phase_logger_length, phase_logger_index, 0, 1);
				control_finish_technical();
			ui_pop();
		ui_pop();
	ui_pop();

	control_background_technical();
	g_i = 0;
	loop(g_buffer_length,
		g_freq = 20*exp(log(18000/20)*g_i/g_buffer_length);
		g_buffer[g_i] = log(correction_amp(g_freq))*20/log(10);
		g_i += 1;
	);
	ui_graph(g_buffer, g_buffer_length, -20, 20);
	control_finish_technical();
) : control_system();

@serialize

preset_version = 1;
file_var(0, preset_version);
