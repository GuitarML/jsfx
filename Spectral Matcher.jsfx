desc:Spectral Matcher

slider1:30<10,50,10>-bands
slider2:4<1,10,0.1>-peak bias
slider3:30<10,200>-smoothing period (ms)

import ui-lib.jsfx-inc

@init

MODEL_MAX_N = 100;
CORRECTION_MAX_N = 100;

allocated_end = allocated_start = ui_setup(0);
function allocate(N) local(result) (
  result = allocated_end;
  allocated_end += N;
  result;
);
function allocate_reset() (
  allocated_end = allocated_start;
  model_target = allocate(MODEL_MAX_N);
  model_shortperiod = allocate(MODEL_MAX_N);
  model_longpower = allocate(MODEL_MAX_N);

  correction_poles_r = allocate(CORRECTION_MAX_N);
  correction_poles_i = allocate(CORRECTION_MAX_N);
  correction_zeroes_r = allocate(CORRECTION_MAX_N);
  correction_zeroes_i = allocate(CORRECTION_MAX_N);
  // Each pole/zero has a conjugate counterpart
  correction_a = allocate(CORRECTION_MAX_N*2);
  correction_b = allocate(CORRECTION_MAX_N*2);
  correction_x_l = allocate[CORRECTION_MAX_N*2];
  correction_y_l = allocate[CORRECTION_MAX_N*2];
  correction_x_r = allocate[CORRECTION_MAX_N*2];
  correction_y_r = allocate[CORRECTION_MAX_N*2];
);
allocate_reset();

function sinh(x) (
  (exp(x) - exp(-x))*0.5;
);

low_freq = 20;
high_freq = 18000;

//bands_N = 0;
function reset_bands(N) local(i, freq, octaves, bw, period, alpha, w0, a0) (
  debug.N = N;
  allocate_reset();
  bands_N = N ? N : model_N;
  
  filter_l_x0 = allocate(bands_N);
  filter_l_x1 = allocate(bands_N);
  filter_l_x2 = allocate(bands_N);
  filter_l_y0 = allocate(bands_N);
  filter_l_y1 = allocate(bands_N);
  filter_l_y2 = allocate(bands_N);
  filter_r_x0 = allocate(bands_N);
  filter_r_x1 = allocate(bands_N);
  filter_r_x2 = allocate(bands_N);
  filter_r_y0 = allocate(bands_N);
  filter_r_y1 = allocate(bands_N);
  filter_r_y2 = allocate(bands_N);

  filter_a1 = allocate(bands_N);
  filter_a2 = allocate(bands_N);
  filter_b0 = allocate(bands_N);
  filter_b1 = allocate(bands_N);
  filter_b2 = allocate(bands_N);

  average1_value = allocate(bands_N);
 
  average2_counter = allocate(bands_N);
  average2_sum = allocate(bands_N);
  
  octaves = log(high_freq/low_freq)/log(2);
  bw = octaves/(bands_N - 1);
  
  i = 0;
  while (i < bands_N) (
    freq = low_freq*exp(log(high_freq/low_freq)*(i + 0.5)/bands_N);
    
    w0 = 2*$pi*freq/srate;
    alpha = sin(w0)*sinh(log(2)/2*bw*w0/sin(w0));
    
    a0 = 1 + alpha;
    filter_a1[i] = -2*cos(w0)/a0;
    filter_a2[i] = (1 - alpha)/a0;
    filter_b0[i] = alpha/a0;
    filter_b1[i] = 0;
    filter_b2[i] = -alpha/a0;

    filter_l_x0[i] = filter_l_x1[i] = filter_l_x2[i] = 0;
    filter_l_y0[i] = filter_l_y1[i] = filter_l_y2[i] = 0;
    filter_r_x0[i] = filter_r_x1[i] = filter_r_x2[i] = 0;
    filter_r_y0[i] = filter_r_y1[i] = filter_r_y2[i] = 0;

    average1_value[i] = 0;
    average2_counter[i] = 0;
    average2_sum[i] = 0;
    
    i += 1;
  );

  period = slider3/1000;
  average1_slew = 1 - exp(-1/period/srate);
  average1_period = period;
  average2_power = slider2;
);
!bands_N ? reset_bands(model_N);

function reset_model(N) local(i, freq) (
  model_N = N;
  model_shortperiod = 0.03;
  model_longpower = 4;
  i = 0;
  while (i < model_N) (
    freq = low_freq*exp(log(high_freq/low_freq)*(i + 0.5)/model_N);
    model_target[i] = min(1, pow(freq/100, 3))*1/pow(freq, 0);
    model_target[i] = min(1, pow(freq/50, 4))*min(1, freq/120)/pow(freq, 0.9);
    i += 1;
  );
);
!model_N ? reset_model(floor(slider1 + 0.5));

function copy_to_model() local(i) (
  model_N = bands_N;
  model_shortperiod = average1_period;
  model_longpower = average2_power;
  
  i = 0;
  while (i < bands_N) (
    model_target[i] = pow(average2_sum[i]/average2_counter[i], 1/average2_power);
    i += 1;
  );
);

function calculate_correction_coefficients() local(i, j, prev0, prev1, prev2, m0, m1, m2) (
  i = 0;
  while (i < correction_coeffs_N) (
    correction_a[i] = 0;
    correction_b[i] = 0;
    correction_x_l[i] = 0;
    correction_x_r[i] = 0;
    correction_y_l[i] = 0;
    correction_y_r[i] = 0;
  );
  correction_a[0] = 1;
  correction_b[0] = 1;

  i = 0;
  // Add poles  
  while (i < correction_N) (
    // Quadratic of (x - P)(x - P*) = x^2 - 2*(P + P*)x + PP* = x - 2*R(P)x + Mag(P)^2
    m0 = 1;
    m1 = -2*correction_poles_r[i];
    m2 = correction_poles_r[i]*correction_poles_r[i] + correction_poles_i[i]*correction_poles_i[i];
    
    j = 0;
    prev1 = prev2 = 0;
    while (j < correction_coeffs_N) (
      prev0 = correction_a[j];
      correction_a[j] = m0*prev0 + m1*prev1 + m2*prev2;
      prev2 = prev1;
      prev1 = prev0;
      j += 1;
    );
    i += 1;
  );

  i = 0;
  // Add zeroes
  while (i < correction_N) (
    // Quadratic of (x - Z)(x - Z*) = x^2 - 2*(Z + Z*)x + ZZ* = x - 2*R(Z)x + Mag(Z)^2
    m0 = 1;
    m1 = -2*correction_zeroes_r[i];
    m2 = correction_zeroes_r[i]*correction_zeroes_r[i] + correction_zeroes_i[i]*correction_zeroes_i[i];
    
    j = 0;
    prev1 = prev2 = 0;
    while (j < correction_coeffs_N) (
      prev0 = correction_b[j];
      correction_b[j] = m0*prev0 + m1*prev1 + m2*prev2;
      prev2 = prev1;
      prev1 = prev0;
      j += 1;
    );
    i += 1;
  );
  debug.m0 = m0;
  debug.m1 = m1;
  debug.m2 = m2;
  debug.prev2 = prev2;
);

function reset_correction() local(i, ratio, angle, radius) (
  correction_viable = 1;
  correction_active = 0;
  correction_learning = 0;
  bands_N != model_N ? reset_bands(model_N);
  
  correction_N = 1;
  correction_coeffs_N = correction_N*2 + 1;
  i = 0;
  while (i < correction_N) (
    ratio = (i + 0.5)/correction_N;
    angle = ratio*ratio*$pi; // Bias towards low frequencies
    // Equally distributed around 0.5 circle
    radius = 0.8;
    correction_poles_r[i] = correction_zeroes_r[i] = cos(angle)*radius;
    correction_poles_i[i] = correction_zeroes_i[i] = sin(angle)*radius;
    
    /*
    correction_poles_r[i] *= 1 - rand(0.01);
    correction_poles_i[i] *= 1 - rand(0.01);
    correction_zeroes_r[i] *= 1 - rand(0.01);
    correction_zeroes_i[i] *= 1 - rand(0.01);
    */
    i += 1;
  );
  correction_poles_r[0] *= 0.9;
  //correction_poles_i[0] *= 0.9;
  calculate_correction_coefficients();
);
!correction_N ? reset_correction();

function correction_amp(freq) local(w0, wr, wi, pr, pi, zr, zi, hr, hi, i, pm2) (
  w0 = freq/srate*2*$pi;
  zr = 0;
  zi = 0;
  pr = 0;
  pi = 0;
  
  i = 0;
  while (i < correction_coeffs_N) (
    zr += correction_b[i]*cos(w0*i);
    zi -= correction_b[i]*sin(w0*i);
    pr += correction_a[i]*cos(w0*i);
    pi += correction_a[i]*sin(w0*i);
    i += 1;
  );
  // Divide Z by P
  hr = zr*pr + zi*pi;
  hi = pr*zi - pi*zr;
  pm2 = pr*pr + pi*pi;
  hr /= pm2;
  hi /= pm2;

  sqrt(hr*hr + hi*hi);
);

function correction_amp(freq) local(w0, zr, zi, vr, vi, v2, hr, hi, i, tmpr, tmpi) (
  w0 = freq/srate*2*$pi;
  zr = cos(w0);
  zi = sin(w0);
  hr = 1;
  hi = 0;
  
  i = 0;
  while (i < correction_N) (
    // Zero - multiply by:
    // v = (z - Z)(z - Z*) = z*z - 2z(Z + Z*) + ZZ*
    vr = (zr*zr - zi*zi) - 2*zr*correction_zeroes_r[i] + (correction_zeroes_r[i]*correction_zeroes_r[i] + correction_zeroes_i[i]*correction_zeroes_i[i]);
    vi = 2*zr*zi - 2*zi*correction_zeroes_r[i];
    
    tmpr = hr;
    tmpi = hi;
    hr = tmpr*vr - tmpi*vi;
    hi = tmpr*vi + tmpi*vr;

    // Pole - divide by:
    // v = (z - P)(z - P*) = z*z - 2z(P + P*) + PP*
    vr = (zr*zr - zi*zi) - 2*zr*correction_poles_r[i] + (correction_poles_r[i]*correction_poles_r[i] + correction_poles_i[i]*correction_poles_i[i]);
    vi = 2*zr*zi - 2*zi*correction_poles_r[i];
    v2 = vr*vr + vi*vi;
    
    // Multiply by conjugate and divide
    tmpr = hr;
    tmpi = hi;
    hr = (tmpr*vr + tmpi*vi)/v2;
    hi = (tmpr*vi - tmpi*vr)/v2;
        
    i += 1;
  );
  sqrt(hr*hr + hi*hi);
);

@slider

!bands_N ? reset_bands(model_N);

@sample

action_reset_bands ? (
  action_reset_bands = 0;
  reset_bands(floor(slider1 + 0.5));
);

i = 0;
while (i < bands_N) (
  filter_l_x0[i] = x0l = spl0;
  filter_l_y0[i] = y0l = filter_b0[i]*x0l + filter_b1[i]*filter_l_x1[i] + filter_b2[i]*filter_l_x2[i] - filter_a1[i]*filter_l_y1[i] - filter_a2[i]*filter_l_y2[i];

  filter_r_x0[i] = x0r = spl1;
  filter_r_y0[i] = y0r = filter_b0[i]*x0r + filter_b1[i]*filter_r_x1[i] + filter_b2[i]*filter_r_x2[i] - filter_a1[i]*filter_r_y1[i] - filter_a2[i]*filter_r_y2[i];
  
  avg = average1_value[i];
  avg = average1_value[i] += ((y0l*y0l + y0r*y0r)*0.5 - avg)*average1_slew;
  
  average2_counter[i] += 1;
  average2_sum[i] += pow(avg, average2_power);
  i += 1;
);

tmp = filter_l_x2;
filter_l_x2 = filter_l_x1;
filter_l_x1 = filter_l_x0;
filter_l_x0 = tmp;

tmp = filter_l_y2;
filter_l_y2 = filter_l_y1;
filter_l_y1 = filter_l_y0;
filter_l_y0 = tmp;

tmp = filter_r_x2;
filter_r_x2 = filter_r_x1;
filter_r_x1 = filter_r_x0;
filter_r_x0 = tmp;

tmp = filter_r_y2;
filter_r_y2 = filter_r_y1;
filter_r_y1 = filter_r_y0;
filter_r_y0 = tmp;

@gfx

function labelled_dial(value, default, low, high, bias, label, displayvalue, displayformat) (
  ui_push_height(50);
    value = control_dial(value, low, high, bias);
    ui_mouse_down() && ui_clickcount() == 2 ? (
      value = default;
    );
  ui_pop();
  
  ui_push_below(50);
    ui_align(0.5, 0);
    ui_text(label);
  ui_pop();
  
  ui_push_above(50);
    ui_align(0.5, 1);
    ui_textnumber(displayvalue, displayformat);
  ui_pop();
  
  value;
);

function draw_correction() local(gi, g_x, g_ratio, g_db, g_y_ratio, g_y, freq) (
  ui_color(0, 0, 0);
  ui_fill();
  
  correction_viable ? (
    gi = 0;
    while (gi < bands_N) (
      g_left = ui_left() + (gi/bands_N)*ui_width();
      g_right = ui_left() + ((gi + 1)/bands_N)*ui_width();
      
      g_ratio = model_target[gi]/pow(average2_sum[gi]/average2_counter[gi], 1/average2_power);
      g_db = log(g_ratio)*10/log(10);
      g_y_ratio = max(0, min(1, (20 - g_db)/40));
      g_y = ui_top() + g_y_ratio*ui_height();
      ui_color(255, 0, 0);
      gfx_line(g_left, g_y, g_right, g_y, 1);
  
      gi += 1;
    );

    gi = 0;
    while (gi < ui_width()) (
      freq = low_freq*exp(log(high_freq/low_freq)*(gi + 0.5)/ui_width());
      g_ratio = correction_amp(freq);
      g_db = log(g_ratio)*20/log(10);
      g_y_ratio = max(0, min(1, (20 - g_db)/40));
      g_y = ui_top() + g_y_ratio*ui_height();
      ui_color(192, 192, 192);
      
      g_x = ui_left() + gi;
      gi > 0 ? (
        gfx_lineto(g_x, g_y);
      ) : (
        gfx_x = g_x;
        gfx_y = g_y;
      );
  
      gi += 1;
    );
  );
  
  control_finish_enabled(1);
);

function draw_averages(draw_model) local(gi, g_left, g_right, g_avg, g_avg_db, g_y_ratio, g_y) (
  ui_color(0, 0, 0);
  ui_fill();
  
  gi = 0;
  while (gi < bands_N) (
    g_left = ui_left() + (gi/bands_N)*ui_width();
    g_right = ui_left() + ((gi + 1)/bands_N)*ui_width();
    
    g_avg = bands_N*average1_value[gi];
    g_avg_db = log(g_avg)*10/log(10);
    g_y_ratio = max(0, min(1, (15 - g_avg_db)/60));
    g_y = ui_top() + g_y_ratio*ui_height();
    ui_color(0, 255, 0);
    gfx_line(g_left, g_y, g_right, g_y, 1);

    g_avg = bands_N*pow(average2_sum[gi]/average2_counter[gi], 1/average2_power);
    g_avg_db = log(g_avg)*10/log(10);
    g_y_ratio = max(0, min(1, (15 - g_avg_db)/60));
    g_y = ui_top() + g_y_ratio*ui_height();
    ui_color(192, 192, 0);
    gfx_line(g_left, g_y, g_right, g_y, 1);
    
    gi += 1;
  );
  
  gi = 0;
  while (draw_model && gi < model_N) (
    g_left = ui_left() + (gi/model_N)*ui_width();
    g_right = ui_left() + ((gi + 1)/model_N)*ui_width();

    g_avg = model_N*model_target[gi];
    g_avg_db = log(g_avg)*10/log(10);
    g_y_ratio = max(0, min(1, (15 - g_avg_db)/60));
    g_y = ui_top() + g_y_ratio*ui_height();
    ui_color(64, 192, 256);
    gfx_line(g_left, g_y, g_right, g_y, 1);
    
    gi += 1;
  );
  
  control_finish_enabled(1);
);

ui_start("main");

ui_screen() == "main" ? (
  control_navbar("Spectrum Matcher", "Learn", "learn");

  ui_push_height(-1);
    ui_split_leftratio(1/3);
      control_button("Reset") ? (
        reset_bands();
        reset_correction();
      );
    ui_split_next();
      g_enabled = bands_N == model_N && correction_viable && !correction_learning;
      control_indicator_button("Correct", g_enabled) ? (
        g_enabled ? (
          correction_active = 1;
          correction_learning = 1;
        );
      );
    ui_split_next();
      g_enabled = bands_N == model_N && correction_active && correction_learning;
      control_indicator_button("Freeze", g_enabled) ? (
        g_enabled ? (
          correction_learning = 0;
        );
      );
    ui_pop();
  ui_pop();
  
  ui_push_above(-1);
    draw_correction(1);
  ui_pop();
  
  ui_push_below(-1);
    draw_averages(1);
  ui_pop();
) : ui_screen() == "learn" ? (
  control_navbar("Spectrum Matcher - Learn", -1, -1);
  
  ui_split_top(130);
    ui_split_leftratio(0.7);
      control_group("Analysis");
      ui_split_leftratio(1/3);
        slider1 = labelled_dial(slider1, 30, 10, 50, 0, "Resolution", log(high_freq/low_freq)/log(2)/slider1, "%0.2f octaves");
      ui_split_next();
        slider2 = labelled_dial(slider2, 4, 1, 10, 1.2, "Peak bias", slider2, "%0.1f");
      ui_split_next();
        slider3 = labelled_dial(slider3, 30, 10, 125, 2.9, "Period", slider3, "%ims");
      ui_pop();
    ui_pop();

    ui_split_topratio(0.5);
      ui_pad();
      control_button("Update") ? (
        reset_correction();
        action_reset_bands = 1;
      );
    ui_split_next();
      ui_pad();
      control_button("Save") ? (
        copy_to_model();
        reset_correction();
      );
    ui_pop();    
  ui_pop();
  
  draw_averages(0);  
) : ui_system();

@serialize

file_var(0, correction_active);
file_var(0, low_freq);
file_var(0, high_freq);
file_var(0, model_N);
file_var(0, model_shortperiod);
file_var(0, model_longpower);

si = 0;
while (si < model_N) (
  file_var(0, model_target[si]);
  si += 1;
);

model_N != bands_N ? (
  reset_bands();
);
