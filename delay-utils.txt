@init

function sinc(x) (
	abs(x) < 0.000001 ? 1 : sin(x)/x;
);

function delay_config(key, value) (
	key == "interpolation samples" ? (
		this.config.interpolation_samples = min(32, max(4, ceil(value)));
	);
);

function delay_setup(freemem, max_delay_samples) local(i, t, wr, w) (
	this.interp_samples = this.config.interpolation_samples ? this.config.interpolation_samples : 4;
	this.buffer_length = ceil(max_delay_samples + this.interp_samples + 1);
	freemem = (this.buffer = freemem) + this.buffer_length;
	i = 0;
	while (i < this.buffer_length) (
		this.buffer[i] = 0;
		i += 1;
	);
	this.interp_scale = 64;
	this.interp_offset = this.interp_samples/2;
	freemem = (this.interp_buffer = freemem) + this.interp_samples*this.interp_scale;
	i = 0;
	while (i < this.interp_samples*this.interp_scale) (
		wr = (i + 0.5)/(this.interp_samples*this.interp_scale);
		// Blackman window
		w = 0.42 - 0.5*cos(wr*$pi*2) + 0.08*cos(wr*$pi*4);
		t = i/this.interp_scale - this.interp_offset;
		this.interp_buffer[i] = sinc(t*$pi)*w; // Windowed sinc
		i += 1;
	);
	freemem;
);

function delay_buffer_size(max_delay_samples) local(length, interp_samples, interp_scale) (
	interp_samples = this.config.interpolation_samples ? this.config.interpolation_samples : 4;
	length = ceil(max_delay_samples + interp_samples + 1);
	interp_scale = 64;
	DELAY# + length + interp_scale*interp_samples;
);

function delay_buffer_setup(obj, max_delay_samples) local(i, t, wr, w, obj, buffer, interp_buffer, freemem) (
	obj[DELAY#interp_samples] = this.config.interpolation_samples ? this.config.interpolation_samples : 4;
	obj[DELAY#length] = ceil(max_delay_samples + obj[DELAY#interp_samples] + 1);
	obj[DELAY#index] = 0;
	freemem = obj + DELAY#;
	buffer = obj[DELAY#buffer] = freemem;
	freemem = obj[DELAY#buffer] + obj[DELAY#length];
	i = 0;
	while (i < obj[DELAY#length]) (
		buffer[i] = 0;
		i += 1;
	);
	obj[DELAY#interp_scale] = 64;
	obj[DELAY#interp_offset] = obj[DELAY#interp_samples]/2;
	interp_buffer = obj[DELAY#interp_buffer] = freemem;
	freemem = interp_buffer + obj[DELAY#interp_samples]*obj[DELAY#interp_scale];
	i = 0;
	while (i < obj[DELAY#interp_samples]*obj[DELAY#interp_scale]) (
		wr = (i + 0.5)/(obj[DELAY#interp_samples]*obj[DELAY#interp_scale]);
		// Blackman window
		w = 0.42 - 0.5*cos(wr*$pi*2) + 0.08*cos(wr*$pi*4);
		t = i/obj[DELAY#interp_scale] - obj[DELAY#interp_offset];
		interp_buffer[i] = sinc(t*$pi)*w; // Windowed sinc
		i += 1;
	);
	freemem;
);

function delay_init(freemem, max_delay_samples) (
	this.delay_setup(freemem, max_delay_samples);
);

function delay_buffer_init(freemem, max_delay_samples) (
	delay_buffer_setup(freemem, max_delay_samples);
);

function delay_input(spl) (
	this.index += 1;
	this.index >= this.buffer_length ? (
		this.index = 0;
	);
	this.buffer[this.index] = spl;
	spl;
);

function delay_buffer_input(obj, spl) local(buffer, index) (
	index = (obj[DELAY#index] += 1);
	obj[DELAY#index] >= obj[DELAY#length] ? (
		index = obj[DELAY#index] = 0;
	);
	buffer = obj[DELAY#buffer];
	buffer[index] = spl;
	spl;
);

function delay_output_linear(samples) local(index, index1, index2, ratio, i, interp_index, sum) (
	index = this.index - max(this.interp_samples, samples + this.interp_offset - 1);
	index1 = floor(index);
	ratio = index - index1;
	while (index1 < 0) (
		index1 += this.buffer_length;
	);

	sum = 0;
	index = index1;
	interp_index = floor((1 - ratio)*this.interp_scale);
	i = 0;
	while (i < this.interp_samples) (
		sum += this.interp_buffer[interp_index]*this.buffer[index];
		interp_index += this.interp_scale;
		index += 1;
		index >= this.buffer_length ? (
			index = 0;
		);
		i += 1;
	);
	sum;
);

function delay_buffer_output_linear(obj, samples) local(index, index1, index2, ratio, i, interp_buffer, buffer, interp_index, sum) (
	debug.obj = obj;
	index = obj[DELAY#index] - max(obj[DELAY#interp_samples], samples + obj[DELAY#interp_offset] - 1);
	index1 = floor(index);
	ratio = index - index1;
	while (index1 < 0) (
		index1 += obj[DELAY#length];
	);
	debug.length = obj[DELAY#length];

	sum = 0;
	index = index1;
	buffer = obj[DELAY#buffer];
	interp_buffer = obj[DELAY#interp_buffer];
	interp_index = floor((1 - ratio)*obj[DELAY#interp_scale]);
	i = 0;
	while (i < obj[DELAY#interp_samples]) (
		sum += interp_buffer[interp_index]*buffer[index];
		interp_index += obj[DELAY#interp_scale];
		index += 1;
		index >= obj[DELAY#length] ? (
			index = 0;
		);
		i += 1;
	);
	sum;
);