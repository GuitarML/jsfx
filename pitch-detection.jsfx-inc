@init

function debug_vector(v) (
	this.0 = v[0];
	this.1 = v[1];
	this.2 = v[2];
	this.3 = v[3];
	this.4 = v[4];
);

function matrix_sane(A, rows, cols) local(row, col, sum, factor) (
	sum = 0;
	row = 0;
	while (row < rows) (
		col = 0;
		while (col < cols) (
			sum += A[row*cols + col];
			col += 1;
		);
		row += 1;
	);
	factor = 1/sum;
	row = 0;
	while (row < rows) (
		col = 0;
		while (col < cols) (
			A[row*cols + col] *= factor;
			col += 1;
		);
		row += 1;
	);
);

// Row-first means (11 12 13 21 22 23 31 32 33)
function matrix_mult(A, B, C, rowsA, midN, colsB) local(sum, row, col, i) (
	row = 0;
	while (row < rowsA) (
		col = 0;
		while (col < colsB) (
			sum = 0;
			i = 0;
			while (i < midN) (
				sum += A[row*midN + i]*B[i*colsB + col];
				i += 1;
			);
			C[row*colsB + col] = sum;
			col += 1;
		);
		row += 1;
	);
);
// Col-first would be (11 21 31 12 22 32 13 23 33)
// This is a transposition operation, so to multiply col-first matrices, swap the order
// 	to get T(T(A)T(B)) = BA
// Vectors are just 1xN matrices, so premultiplying a column vector is matrix_mult(A, v, v2, rowsA, colsA, 1)

function pitch_detection_init(freemem) local(buffer_length, mem_start) (
	mem_start = freemem;
	this.window_length = ceil(0.05*srate);
	this.window_oversample = 2;
	this.fft_size = pow(2, ceil(log(this.window_length*1*this.window_oversample)/log(2)));
	this.fft_buffer = freemem;
	freemem += this.fft_size*2;
	this.sdft_step = ceil(this.window_length*0.25);
	this.sdft_remaining = this.window_length;
	
	this.options_N = 5; // Number of peaks to extract
	freemem += this.history_step*this.history_length;

	this.score_noise_prob = 0.25;
	
	this.working_vector = freemem;
	freemem += this.options_N;
	this.working_vector_2 = freemem;
	freemem += this.options_N;
	this.working_vector_3 = freemem;
	freemem += this.options_N;
	
	buffer_length = this.buffer_length = ceil(this.window_length);
	this.buffer_left = freemem;
	this.buffer_right = freemem + buffer_length;
	this.buffer_index = 0;
	freemem += buffer_length*2;
	
	this.current_freq = 0;
	
	// Wipe clean
	memset(mem_start, 0, freemem - mem_start);
	
	freemem;
);

function pitch_detection_delay() (
	this.window_length*0.5;
);

// Window goes 0-1-0
function pitch_detection_window(i) (
	0.5 - 0.5*cos((i + 0.5)/this.window_length*2*$pi);
);

// Compensate for window's effect on autocorrelation
function pitch_detection_window_compensation(i) (
	min(10, 1/this.pitch_detection_window(this.window_length*0.5 + i*0.49));
);

function pitch_detection_recalc(freqs, observations) local(short_size, i, i2, i3, real1, imag1, real2, imag2, mag2, index, ratio, window, value, peak_index, l, r, a, b, ratio, window, freq, amp, crossed_zero, replace_index, replace_peak) (
	short_size = this.fft_size/this.window_oversample;
	i = 0;
	while (i < this.window_length) (
		index = this.buffer_index - i - 1;
		index < 0 ? index += this.buffer_length;
		window = this.pitch_detection_window(i);
		window /= short_size;
		this.fft_buffer[2*i] = this.buffer_left[index]*window;
		this.fft_buffer[2*i + 1] = this.buffer_right[index]*window;
		i += 1;
	);
	while (i < short_size) (
		this.fft_buffer[2*i] = this.fft_buffer[2*i + 1] = 0;
		i += 1;
	);
	
	fft(this.fft_buffer, short_size);
	fft_permute(this.fft_buffer, short_size);

	this.fft_buffer[0] = this.fft_buffer[1] = 0;
	i = 1;
	while (i < short_size*0.5) (
		i2 = short_size - i;
		i2b = this.fft_size - i;
		real1 = this.fft_buffer[2*i];
		imag1 = this.fft_buffer[2*i + 1];
		real2 = this.fft_buffer[2*i2];
		imag2 = this.fft_buffer[2*i2 + 1];
		
		mag2 = (real1*real1 + imag1*imag1 + real2*real2 + imag2*imag2);
		this.fft_buffer[2*i] = this.fft_buffer[2*i2b] = sqrt(mag2);
		this.fft_buffer[2*i + 1] = this.fft_buffer[2*i2b + 1] = 0;
		i += 1;
	);
	while (i <= this.fft_size - short_size*0.5) (
		this.fft_buffer[2*i] = this.fft_buffer[2*i + 1] = 0;
		i += 1;
	);
	fft_ipermute(this.fft_buffer, this.fft_size);
	ifft(this.fft_buffer, this.fft_size);

	i = 0;
	while (i < this.options_N) (
		freqs[i] = observations[i] = 0;
		i += 1;
	);
	freqs[0] = 0;
	observations[0] = this.score_noise_prob;

	i = 1;
	while (i < this.fft_size*0.5) (
		this.fft_buffer[2*i] *= this.pitch_detection_window_compensation(i);
		i += 1;
	);

	amp = this.fft_buffer[0];
	i = 1;
	while (i < this.fft_size*0.5) (
		iH = floor(i*0.5 + 0.5);
		i2 = min(this.fft_size*0.5, i*2);
		i3 = min(this.fft_size*0.5, i*3);
		value = this.fft_buffer[2*i];
		//value = (this.fft_buffer[0] + this.fft_buffer[2*i])/2;
		//value = (this.fft_buffer[0]*2 + this.fft_buffer[2*i]*2)/4;
		//value = (this.fft_buffer[0]*3 + this.fft_buffer[2*i]*4 + this.fft_buffer[2*i2]*2)/9;
		value = (this.fft_buffer[0]*4 + this.fft_buffer[2*i]*6 + this.fft_buffer[2*i2]*4 + this.fft_buffer[2*i3]*2)/16;
		value /= this.fft_buffer[0];
		this.fft_buffer[2*i] = value;
		i += 1;
	);
	this.fft_buffer[0] = 1;
	
	i = 1;
	crossed_zero = 0;
	while (i < this.window_length*0.5*this.window_oversample) (
		value = this.fft_buffer[2*i];
		l = this.fft_buffer[2*(i - 1)];
		r = this.fft_buffer[2*(i + 1)];
		
		value <= this.score_noise_prob ? crossed_zero = 1;
		
		// Local peak
		crossed_zero && l < value && r <= value ? (
			// Quadratic interpolation of peak
			a = (l + r - 2*value);
			b = (r - l);
			peak_index = i - b/(2*a);

			// Find smallest existing observation
			replace_index = 0;
			replace_peak = value;
			i2 = 1;
			while (i2 < this.options_N) (
				observations[i2] < replace_peak ? (
					replace_peak = observations[i2];
					replace_index = i2;
				);
				i2 += 1;
			);
			replace_index ? (
				observations[replace_index] = value;
				freqs[replace_index] = srate/peak_index*this.window_oversample;
			);
		);
		i += 1;
	);

	i = 1;
	while (i < this.fft_size*0.5) (
		rand() < 0.5 ? (
			this.fft_buffer[2*i] = this.score_noise_prob;
		);
		i += 1;
	);

	/*
	i = 0;
	while (i < this.options_N) (
		observations[i] = pow(observations[i], this.prob_power);
		i ? (
			index = floor(srate/freqs[i] + 0.5);
			this.fft_buffer[2*index] = -1;
		);
		i += 1;
	);
	*/
	amp;
);

function pitch_detection_step() local(i, freqs, amp, likelihoods, total, random, selected_index, best) (
	current_freqs = this.working_vector;
	likelihoods = this.working_vector_3;
	this.current_amp = this.pitch_detection_recalc(current_freqs, likelihoods);
	
	// choose the most likely
	total = 0;
	i = 0;
	while (i < this.options_N) (
		total += likelihoods[i];
		i += 1;
	);

	0 ? (
		selected_index = 0;
		random = rand()*total;
		i = 0;
		while (i < this.options_N && random >= 0) (
			random < likelihoods[i] ? (
				selected_index = i;
			);
			random -= likelihoods[i];
			i += 1;
		);
		this.current_freq = current_freqs[selected_index];
		this.current_tonality = likelihoods[selected_index];
	) : (
		selected_index = 0;
		best = current_freqs[0];
		i = 0;
		while (i < this.options_N) (
			best < likelihoods[i] ? (
				best = likelihoods[i];
				selected_index = i;
			);
			i += 1;
		);
		this.current_freq = current_freqs[selected_index];
		this.current_tonality = likelihoods[selected_index];
	);
);

function pitch_detection_sample(left, right) (
	this.buffer_left[this.buffer_index] = left;
	this.buffer_right[this.buffer_index] = right;
	this.buffer_index += 1;
	this.buffer_index >= this.buffer_length ? this.buffer_index = 0;
	
	this.sdft_remaining -= 1;
	this.sdft_remaining <= 0 ? (
		this.sdft_remaining += this.sdft_step;
		this.pitch_detection_step();
	);
	this.current_freq;
);

function pitch_detection_tonality() (
	max(0, this.current_tonality - this.score_noise_prob)/(1 - this.score_noise_prob);
);

function pitch_detection_amp() (
	this.current_amp*this.pitch_detection_tonality();
);

function pitch_detection_freq() (
	this.current_freq;
);

function pitch_detection_note() (
	12*log(this.current_freq/440)/log(2) + 69;
);
