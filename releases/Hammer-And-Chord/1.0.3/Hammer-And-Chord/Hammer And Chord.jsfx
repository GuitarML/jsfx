/* Generated by: https://www.npmjs.com/package/jsfx-preprocessor */
desc:Hammer And Chord (Polyphonic Synth/Resonator by Geraint Luff)

in_pin:Left
in_pin:Right
out_pin:Left
out_pin:Right

slider1:decay_wavelengths_on=50<1,1000,1>-Decay (on)
slider2:release_ms=50<1,100,1>-Release (ms)
slider3:portamento_ms=5<0,100,1>-Portamento (ms)
slider4:impulse_brightness=30<0.1,100,0.01>-Impulse brightness
slider5:impulse_velocity=1<0,2,0.01>-Impulse velocity
slider6:resonator_scaling=0.1<0,1,0.01>-Input scaling (sustain, impulse)
slider7:invert_feedback=0<0,1,1{positive,negative}>-Feedback
slider8:impulse_amp=1<0,1,0.01>-Impulse volume
slider9:decay_period=1<0,1,0.01>-Decay period
slider10:damping_factor=1<0,2,0.01>-Damping
slider11:filter_freq=2000<500,16000,1>-Damping freq
slider12:ring_mod=0<0,1,1{off,on}>-Anti-tonal ring mod

import ui-lib.jsfx-inc
import synth-framework.jsfx-inc
import delay-utils.jsfx-inc
import filter-utils.jsfx-inc

@init

function tanh(x) (
	x >= 20 ? (
		1;
	) : x <= -20 ? (
		-1;
	) : (
		(exp(2*x) - 1)/(exp(2*x) + 1);
	);
);

min_freq = 10;
max_delay_samples = srate/min_freq;
delay_buffer_length = delay_buffer_size(max_delay_samples);
filter_buffer_length = filter_buffer_size();

freemem = 0;
freemem = ui_setup(freemem);
freemem = synth_setup(freemem, 14/*NOTE: impulse_amp, delay_samples, buffer0, buffer1, filter0, resonator_gain, invert_feedback, filter1, decay_factor, pan_left, pan_right, mod_gain, mod_filter0, mod_filter1*/ + delay_buffer_length*2 + filter_buffer_length*4);

delay_samples = max_delay_samples;
delay_samples_target = max_delay_samples;

latest_release = 0;

@block

anticipation_samples = 0;//ceil(anticipation_ms*srate/1000);
pdc_bot_ch = 0;
pdc_top_ch = 2;
pdc_delay = anticipation_samples;

synth_block();

portamento_time = portamento_ms/1000;
delay_samples_slew_factor = portamento_time ? (1 - exp(-1/srate/portamento_time)) : 1;
decay_factor_on = exp(-1/decay_wavelengths_on);
decay_reference_freq = 220;

// Impulse timbre parameters
impulse_length_samples = 0.01*srate;

release_samples = 2*release_ms/1000*srate;

resonator_gain = 0;

!filter_freq ? (
	filter_freq = 2000;
);
filter_bandwidth = 2;

@sample

synth_sample();

latest_note = -1;

function impulse(note) local(attack, phase, amp) (
	attack = synth_attack(note) - anticipation_samples;
	attack >= 0 && attack < impulse_length_samples ? (
		phase = attack/impulse_length_samples - 0.5;
		phase2 = impulse_brightness*phase*pow(synth_velocity(note)/127, 1);
		amp = note[0/*NOTE:impulse_amp*/]*(1 + 0.25*impulse_brightness)/(0.1 + impulse_brightness);
		tanh(phase2*2*$pi)*(0.5 + 0.5*cos(phase*2*$pi))*amp;
	) : 0;
);

output0 = output1 = 0;

note = synth_note_first();
while (note > 0) (
	note_min_release = min(note_min_release, synth_release(note));
	synth_needs_init(note) ? (
		mem = note + 14/*NOTE: impulse_amp, delay_samples, buffer0, buffer1, filter0, resonator_gain, invert_feedback, filter1, decay_factor, pan_left, pan_right, mod_gain, mod_filter0, mod_filter1*/;
		note[1/*NOTE:delay_samples*/] = min(max_delay_samples, srate/synth_freq(note));
		note[2/*NOTE:buffer0*/] = mem;
		mem = delay_buffer_init(mem, max_delay_samples);
		note[3/*NOTE:buffer1*/] = mem;
		mem = delay_buffer_init(mem, max_delay_samples);
		note[4/*NOTE:filter0*/] = mem;

		decay_factor = pow(decay_factor_on, 1 + 2*(1 - synth_velocity(note)/127));
		decay_normalisation = decay_reference_freq/synth_freq(note);
		decay_normalisation = 1 + (decay_normalisation - 1)*decay_period;
		decay_factor = pow(decay_factor, decay_normalisation);
		resonator_gain = sqrt(1 - abs(decay_factor_on));
		resonator_gain += (1 - resonator_gain)*resonator_scaling;
		note[5/*NOTE:resonator_gain*/] = resonator_gain;

		note[6/*NOTE:invert_feedback*/] = invert_feedback;
		invert_feedback ? decay_factor = -sqrt(decay_factor);

		filter_gain = pow(abs(decay_factor), damping_factor);
		mem = filter_buffer_init(mem);
		filter_buffer_highshelf_gainband(note[4/*NOTE:filter0*/], filter_freq, filter_gain, filter_bandwidth);
		note[7/*NOTE:filter1*/] = mem;
		mem = filter_buffer_init(mem);
		filter_buffer_highshelf_gainband(note[7/*NOTE:filter1*/], filter_freq, filter_gain, filter_bandwidth);

		note[8/*NOTE:decay_factor*/] = decay_factor;

		note[0/*NOTE:impulse_amp*/] = impulse_amp*pow(synth_velocity(note)/127, impulse_velocity);
		pan = 0.5 + (rand() - 0.5)*0.05;
		note[9/*NOTE:pan_left*/] = (1 - pan)*2;
		note[10/*NOTE:pan_right*/] = pan*2;

		mod_filter_freq = synth_freq(note)*0.5;
		note[11/*NOTE:mod_gain*/] = sqrt(srate/mod_filter_freq);
		note[12/*NOTE:mod_filter0*/] = mem;
		mem = filter_buffer_init(mem);
		filter_buffer_lowpass(note[12/*NOTE:mod_filter0*/], mod_filter_freq, 0.5);
		note[13/*NOTE:mod_filter1*/] = mem;
		mem = filter_buffer_init(mem);
		filter_buffer_lowpass(note[13/*NOTE:mod_filter1*/], mod_filter_freq, 0.5);
	);
	synth_release(note) >= release_samples ? (
		synth_stop(note);
	) : (
		decay_factor = note[8/*NOTE:decay_factor*/];
		resonator_gain = note[5/*NOTE:resonator_gain*/];
		impulse_value = impulse(note);

		delay_samples_target = min(max_delay_samples, srate/synth_freq(note));
		delay_samples = note[1/*NOTE:delay_samples*/];
		delay_samples += (delay_samples_target - delay_samples)*delay_samples_slew_factor;
		delay_freq = srate/delay_samples;
		note[1/*NOTE:delay_samples*/] = delay_samples;

		note[6/*NOTE:invert_feedback*/] ? delay_samples *= 0.5;

		buffer0 = note[2/*NOTE:buffer0*/];
		buffer1 = note[3/*NOTE:buffer1*/];
		plotbuffer = buffer0;
		delayed0 = delay_buffer_output_linear(buffer0, delay_samples - 1);
		delayed1 = delay_buffer_output_linear(buffer1, delay_samples - 1);
		delayed0 = filter_buffer_sample(note[4/*NOTE:filter0*/], delayed0);
		delayed1 = filter_buffer_sample(note[7/*NOTE:filter1*/], delayed1);

		excitation0 = spl0;
		excitation1 = spl1;
		ring_mod ? (
			noise = (rand()*2 - 1)*note[11/*NOTE:mod_gain*/];
			excitation0 = filter_buffer_sample(note[12/*NOTE:mod_filter0*/], noise)*excitation0;
			noise = (rand()*2 - 1)*note[11/*NOTE:mod_gain*/];
			excitation1 = filter_buffer_sample(note[13/*NOTE:mod_filter1*/], noise)*excitation1;
		);
		excitation0 = impulse_value*note[9/*NOTE:pan_left*/] + excitation0*resonator_gain + delayed0*decay_factor;
		excitation1 = impulse_value*note[10/*NOTE:pan_right*/] + excitation1*resonator_gain + delayed1*decay_factor;
		delay_buffer_input(buffer0, excitation0);
		delay_buffer_input(buffer1, excitation1);

		synth_release(note) > 0 ? (
			release_ratio = synth_release(note)/release_samples;
			env = pow(1 - release_ratio, 3);
			delayed0 *= env;
			delayed1 *= env;
		);

		output0 += delayed0;
		output1 += delayed1;
		ring_mod ? (
			output0 += excitation0;
			output1 += excitation1;
		);
	);
	note = synth_note_next(note);
);

spl0 = output0;
spl1 = output1;

@gfx 620 439

function labelled_default_dial(value, low, high, bias, label, format_text, default) local(height) (
	height = min(ui_height()/2, 50);
	ui_push_height(height);
		value = control_dial(value, low, high, bias);
		ui_click() && ui_clickcount() == 2 ? (
			value = default;
		);
	ui_pop(height);
	ui_push_above(height);
		ui_text(label);
	ui_pop(height);
	ui_push_below(height);
		ui_textnumber(value, format_text);
	ui_pop();
	value;
);

function labelled_switch(value, label, format_text) local(height) (
	height = min(ui_height()/2, 50);
	ui_push_height(height);
		ui_push_heighttext(-1);
			ui_push_width(50);
				value = control_switch(value);
			ui_pop();
		ui_pop();
	ui_pop(height);
	ui_push_above(height);
		ui_text(label);
	ui_pop(height);
	ui_push_below(height);
		ui_text(format_text);
	ui_pop();
	value;
);

control_start("main", "tron");

ui_screen() == "main" ? (
	control_navbar("Hammer And Chord (polyphonic)", -1, -1);
	ui_split_topratio(0.5);
		ui_split_leftratio(3/5);
			control_group("Envelope");
			ui_split_leftratio(1/3);
				decay_wavelengths_on = labelled_default_dial(decay_wavelengths_on, 1, 1000, 4, "Decay", "", 50);
			ui_split_next();
				decay_period = labelled_default_dial(decay_period, 0, 1, 0, "Note decay", decay_period < 0.5 ? "wavelength" : "constant time", 1);
			ui_split_next();
				release_ms = labelled_default_dial(release_ms, 0, 500, 4, "Release", "%ims", 50);
			ui_pop();
		ui_split_next();
			control_group("Damping");
			ui_split_leftratio(1/2);
				filter_freq = labelled_default_dial(filter_freq, 500, 16000, log(16000/500), "Freq", "%iHz", 2000);
			ui_split_next();
				damping_factor = labelled_default_dial(damping_factor, 0, 4, 1.5, "Amount", "", 1);
			ui_pop();
		ui_pop();
	ui_split_next();
		ui_split_leftratio(3/6);
			control_group("Impulse");
			ui_split_leftratio(1/3);
				impulse_brightness = labelled_default_dial(impulse_brightness, 0.1, 100, log(1000), "Brightness", "", 30);
			ui_split_next();
				impulse_amp = labelled_default_dial(impulse_amp, 0, 1, log(100), "Volume", "", 1);
			ui_split_next();
				impulse_velocity = labelled_default_dial(impulse_velocity, 0, 2, 0, "Velocity", "", 1);
			ui_pop();
		ui_split_next();
			control_group("Resonator");
			ui_split_leftratio(1/3);
				invert_feedback = labelled_switch(invert_feedback, "Feedback", invert_feedback ? "negative" : "positive");
			ui_split_next();
				resonator_scaling = labelled_default_dial(resonator_scaling, 0, 1, 0, "Input type", resonator_scaling < 0.25 ? "continuous" : resonator_scaling < 0.75 ? "hybrid" : "impulse", 0.1);
			ui_split_next();
				ring_mod = labelled_switch(ring_mod, "De-tonal", ring_mod ? "on" : "off");
			ui_pop();
		ui_pop();
	ui_pop();
) : ui_system();
